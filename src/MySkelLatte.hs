-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelLatte where

import Prelude (($), Either(..), String, (++), Show, show, unwords, foldl, map, Bool(..), Maybe(..), null, any, (&&), not, (==), head, Eq, length, (/=), return, (||), Int, otherwise, error)
import Control.Monad (foldM, mapM)
import qualified AbsLatte
import AbsLatte
import qualified Data.Map as Map

type Err = Either String
type Result = Err String

data FuncType = FuncType String [String] deriving (Show)

type Env = Map.Map String FuncType
type VarEnv = Map.Map String String

builtinFunctions :: Env
builtinFunctions = Map.fromList
  [ ("printInt", FuncType "void" ["int"])
  , ("printString", FuncType "void" ["string"])
  , ("error", FuncType "void" [])
  , ("readInt", FuncType "int" [])
  , ("readString", FuncType "string" [])
  ]

checkSemantics :: Program -> Result
checkSemantics program = do
  let collectResult = collectFunctionTypes program
  case collectResult of
    Left err -> Left err
    Right env -> do
      case Map.lookup "main" env of
        Nothing -> Left "Error: Function 'main' is not defined."
        Just _ -> transProgram program env

collectFunctionTypes :: Program -> Err Env
collectFunctionTypes (Program _ topdefs) = foldM addFunctionToEnv builtinFunctions topdefs

addFunctionToEnv :: Env -> TopDef -> Err Env
addFunctionToEnv env (FnDef pos returnType ident args _) = do
  let funcName = getIdentName ident
      argTypes = map getArgType args
  if Map.member funcName env
    then
      let message = "Error: Function '" ++ funcName ++ "' is already declared."
      in Left (positionErrorDirectPos message pos)
    else do
      if funcName == "main" 
        then do
          if isValidMainReturn returnType
            then if not (isValidMainArgs argTypes)
              then Left (positionError "Error: Function 'main' must take no arguments." (head argTypes))
              else return ()
            else Left (positionError "Error: Function 'main' must return 'int'." returnType)
        else return ()

      let formattedArgTypes = map getType argTypes
          formattedReturnType = getType returnType
          funcType = FuncType formattedReturnType formattedArgTypes
          updatedEnv = Map.insert funcName funcType env
      Right updatedEnv

getIdentName :: Ident -> String
getIdentName (Ident name) = name

getArgType :: Arg -> Type
getArgType (Arg _ argType _) = argType

isValidMainReturn :: Type -> Bool
isValidMainReturn (Int _) = True
isValidMainReturn _ = False

isValidMainArgs :: [Type] -> Bool
isValidMainArgs argTypes = null argTypes

positionError :: String -> (HasPosition a) => a -> String
positionError message entity = do
  case hasPosition entity of
    Just pos -> "Error at position " ++ show pos ++ ": " ++ message
    Nothing  -> "Error: " ++ message

positionErrorDirectPos :: String -> BNFC'Position -> String
positionErrorDirectPos message pos = 
  case getPositionPair pos of
    Just (x, y) -> "Error at position (" ++ show x ++ ", " ++ show y ++ "): " ++ message
    Nothing     -> "Error: " ++ message

getPositionPair :: BNFC'Position -> Maybe (Int, Int)
getPositionPair (Just (x, y)) = Just (x, y)
getPositionPair Nothing       = Nothing

transProgram :: Program -> Env -> Result
transProgram (Program _ topdefs) env = checkTopDefs topdefs env

checkTopDefs :: [TopDef] -> Env -> Result
checkTopDefs [] env = Right "OK"
checkTopDefs (topdef:rest) env = do
  case transTopDef topdef env of
    Left err -> Left err
    Right _  -> checkTopDefs rest env

transTopDef :: TopDef -> Env -> Result
transTopDef (FnDef pos _ ident args block) funEnv = do
  let varEnv = Map.empty
  case getReturnType (getIdentName ident) funEnv of
    Nothing -> Left ("Error: Function '" ++ getIdentName ident ++ "' not found in environment.")
    Just returnType -> 
      case checkArgs args varEnv of
        Left err -> Left err
        Right updatedEnv -> do
          checkBlockResult <- checkBlock block updatedEnv Map.empty funEnv returnType
          if containsGuaranteedReturnBlock block
            then Right "OK"
            else if returnType /= "void"
                 then Left (positionErrorDirectPos ("Error: Missing guaranteed return statement in function " ++ (getIdentName ident)) pos)
                 else Right "OK"

getReturnType :: String -> Env -> Maybe String
getReturnType funcName funcEnv = case Map.lookup funcName funcEnv of
  Just (FuncType returnType _) -> Just returnType
  Nothing -> Nothing  

checkArgs :: [Arg] -> VarEnv -> Err VarEnv
checkArgs [] varEnv = Right varEnv
checkArgs (Arg pos argType ident:rest) varEnv = do
  let varName = getIdentName ident
  if Map.member varName varEnv
    then 
      let message = "Error: Argument '" ++ varName ++ "' is already declared."
      in Left (positionErrorDirectPos message pos)
    else
      let updatedEnv = Map.insert varName (getType argType) varEnv
      in checkArgs rest updatedEnv

checkBlock :: Block -> VarEnv -> VarEnv -> Env -> String -> Result
checkBlock (Block _ stmts) localVarEnv globalVarEnv funEnv returnType = do
  case traverseStmts stmts localVarEnv globalVarEnv funEnv returnType of 
    Left err -> Left err
    Right _ -> Right "OK"

containsGuaranteedReturn :: Stmt -> Bool
containsGuaranteedReturn (Ret _ _) = True
containsGuaranteedReturn (VRet _) = True

containsGuaranteedReturn (BStmt _ block) = containsGuaranteedReturnBlock block

containsGuaranteedReturn (CondElse _ expr stmt1 stmt2) =
  case expr of
    ELitTrue _ -> containsGuaranteedReturn stmt1
    ELitFalse _ -> containsGuaranteedReturn stmt2
    _ -> containsGuaranteedReturn stmt1 && containsGuaranteedReturn stmt2

containsGuaranteedReturn (Cond _ expr stmt) =
  case expr of
    ELitTrue _ -> containsGuaranteedReturn stmt
    ELitFalse _ -> False
    _ -> False

containsGuaranteedReturn (While _ expr stmt) =
  case expr of
    ELitFalse _ -> False
    ELitTrue _ -> containsGuaranteedReturn stmt
    _ -> False

containsGuaranteedReturn _ = False

containsGuaranteedReturnBlock :: Block -> Bool
containsGuaranteedReturnBlock (Block _ stmts) = any containsGuaranteedReturn stmts

traverseStmts :: [Stmt] -> VarEnv -> VarEnv -> Env -> String -> Err VarEnv
traverseStmts [] localVarEnv globalVarEnv _ _ = Right localVarEnv
traverseStmts (stmt:rest) localVarEnv globalVarEnv funEnv returnType = do
  let stmtResponse = checkStmt stmt localVarEnv globalVarEnv funEnv returnType
  case stmtResponse of
    Left err -> Left err
    Right newVarEnv -> traverseStmts rest newVarEnv globalVarEnv funEnv returnType

getType :: Type -> String
getType (Int _) = "int"
getType (Str _) = "string"
getType (Bool _) = "bool"
getType (Void _) = "void"
getType (Fun _ returnType paramTypes) = getType returnType

lookupVar :: String -> VarEnv -> VarEnv -> Maybe String
lookupVar varName localVarEnv globalVarEnv = 
  case Map.lookup varName localVarEnv of
    Just varType -> Just varType
    Nothing -> 
      Map.lookup varName globalVarEnv

checkStmt :: Stmt -> VarEnv -> VarEnv -> Env -> String -> Err VarEnv
checkStmt (Empty _) localVarEnv globalVarEnv _ _ = Right localVarEnv

checkStmt (Decl pos varType items) localVarEnv globalVarEnv funEnv _ = do
  let declResponse = processDecl pos (getType varType) items localVarEnv globalVarEnv funEnv
  case declResponse of
    Left err -> Left err
    Right newVarEnv -> Right newVarEnv
   
checkStmt (Ass pos ident expr) localVarEnv globalVarEnv funEnv returnType = do
  let varName = getIdentName ident
  case lookupVar varName localVarEnv globalVarEnv of 
    Nothing -> Left (positionErrorDirectPos ("Error: Variable '" ++ varName ++ "' is not declared.") pos)
    Just varType -> do
      exprType <- checkExprType expr localVarEnv globalVarEnv funEnv
      if exprType == varType
        then Right localVarEnv
        else Left (positionErrorDirectPos 
          ("Error: Type mismatch in assignment to variable '" ++ varName ++ "'.\nExpected: " 
          ++ varType ++ "\nGot: " ++ exprType) pos)


checkStmt (BStmt _ block) localVarEnv globalVarEnv funEnv returnType = do
  let combinedEnv = Map.union localVarEnv globalVarEnv 
  checkBlock block Map.empty combinedEnv funEnv returnType
  Right localVarEnv

checkStmt (Incr pos ident) localVarEnv globalVarEnv _ _= do
  let varName = getIdentName ident
  case lookupVar varName localVarEnv globalVarEnv of
    Just varType ->
      if varType == "int"
        then Right localVarEnv
        else Left (positionErrorDirectPos ("Error: Increment requires an integer, but '" ++ varName ++ "' is of type " ++ varType ++ ".") pos)
    Nothing -> Left (positionErrorDirectPos ("Error: Variable '" ++ varName ++ "' is not declared.") pos)

checkStmt (Decr pos ident) localVarEnv globalVarEnv _ _ = do
  let varName = getIdentName ident
  case lookupVar varName localVarEnv globalVarEnv of
    Just varType ->
      if varType == "int"
        then Right localVarEnv
        else Left (positionErrorDirectPos ("Error: Decrement requires an integer, but '" ++ varName ++ "' is of type " ++ varType ++ ".") pos)
    Nothing -> Left (positionErrorDirectPos ("Error: Variable '" ++ varName ++ "' is not declared.") pos)

checkStmt (Cond pos expr stmt) localVarEnv globalVarEnv funEnv returnType = do
  exprType <- checkExprType expr localVarEnv globalVarEnv funEnv
  case exprType of
    "bool" -> do
      checkStmt stmt localVarEnv globalVarEnv funEnv returnType
      return localVarEnv
    _ -> 
      Left (positionError "Error: Condition must be of type 'Bool'." expr)

checkStmt (CondElse pos expr stmt1 stmt2) localVarEnv globalVarEnv funEnv returnType = do
  exprType <- checkExprType expr localVarEnv globalVarEnv funEnv
  if exprType /= "bool"
    then Left (positionErrorDirectPos "Error: Condition expression must be of type Bool." pos)
    else do
      checkStmt stmt1 localVarEnv globalVarEnv funEnv returnType
      checkStmt stmt2 localVarEnv globalVarEnv funEnv returnType
      Right localVarEnv   
  
checkStmt (While pos expr stmt) localVarEnv globalVarEnv funEnv returnType = do
  exprType <- checkExprType expr localVarEnv globalVarEnv funEnv
  if exprType /= "bool"
    then Left (positionErrorDirectPos "Error: While loop condition must be of type Bool." pos)
    else do
      checkStmt stmt localVarEnv globalVarEnv funEnv returnType
      Right localVarEnv

checkStmt (SExp pos expr) localVarEnv globalVarEnv funEnv returnType = do
  _ <- checkExprType expr localVarEnv globalVarEnv funEnv
  Right localVarEnv

checkStmt (Ret pos expr) localVarEnv globalVarEnv funEnv returnType = do
  exprType <- checkExprType expr localVarEnv globalVarEnv funEnv
  if exprType == returnType
    then Right localVarEnv
    else Left (positionErrorDirectPos ("Error: Return type mismatch. Expected: " 
            ++ returnType ++ ", Got: " ++ exprType) pos)

checkStmt (VRet pos) localVarEnv globalVarEnv funEnv returnType =
  if returnType == "void"
    then Right localVarEnv
    else Left (positionErrorDirectPos "Error: Return without value in a non-void function." pos)

processDecl :: BNFC'Position -> String -> [Item] -> VarEnv -> VarEnv -> Env -> Err VarEnv
processDecl _ _ [] localVarEnv _ _ = Right localVarEnv
processDecl pos varType (item:rest) localVarEnv globalVarEnv funEnv = do
  let processItemResponse = processItem pos varType item localVarEnv globalVarEnv funEnv
  case processItemResponse of
    Left err -> Left err
    Right newVarEnv -> processDecl pos varType rest newVarEnv globalVarEnv funEnv

processItem :: BNFC'Position -> String -> Item -> VarEnv -> VarEnv -> Env -> Err VarEnv
processItem pos varType item localVarEnv globalVarEnv funEnv = do
  let varName = case item of
        NoInit _ ident -> getIdentName ident
        Init _ ident _ -> getIdentName ident
  if Map.member varName localVarEnv 
    then Left (positionErrorDirectPos ("Error: Variable '" ++ varName ++ "' already declared.") pos)
    else case item of
      NoInit _ _ -> Right (Map.insert varName varType localVarEnv) 
      Init initPos _ expr -> do
        exprType <- checkExprType expr localVarEnv globalVarEnv funEnv
        if exprType == varType
          then Right (Map.insert varName varType localVarEnv) 
          else Left (positionError ("Error: Type mismatch in initialization of variable '" ++ varName ++ "'. \nExpected: " ++ show varType ++ "\nGot: " ++ show exprType) expr)

getVariableType :: Ident -> VarEnv -> VarEnv -> Err String
getVariableType ident localVarEnv globalVarEnv = do
  case lookupVar (getIdentName ident) localVarEnv globalVarEnv of 
    Just varType -> Right varType
    Nothing -> Left ("Error: Variable '" ++ (getIdentName ident) ++ "' not declared.")

checkExprType :: Expr -> VarEnv -> VarEnv -> Env -> Err String
checkExprType (EVar pos ident) localVarEnv globalVarEnv _ = do
  case getVariableType ident localVarEnv globalVarEnv of 
    Left err -> Left (positionErrorDirectPos err pos)
    Right varType -> Right varType

checkExprType (ELitInt _ _) _ _ _= Right "int"
checkExprType (ELitTrue _) _ _ _= Right "bool"
checkExprType (ELitFalse _) _ _ _= Right "bool"
checkExprType (EString _ _) _ _ _= Right "string"

checkExprType (Neg pos expr) localVarEnv globalVarEnv funEnv = do
  exprType <- checkExprType expr localVarEnv globalVarEnv funEnv
  case exprType of
    "int" -> Right "int"
    _     -> Left (positionErrorDirectPos "Error: Negation requires an integer." pos)

checkExprType (Not pos expr) localVarEnv globalVarEnv funEnv = do
  exprType <- checkExprType expr localVarEnv globalVarEnv funEnv
  case exprType of
    "bool" -> Right "bool"
    _      -> Left (positionErrorDirectPos "Error: 'Not' operator requires a boolean." pos)

checkExprType (EApp pos ident args) localVarEnv globalVarEnv funEnv = do
  let funcName = getIdentName ident
  case Map.lookup funcName funEnv of
    Nothing -> Left (positionErrorDirectPos ("Error: Function '" ++ funcName ++ "' not declared.") pos)
    Just (FuncType returnType paramTypes) -> do
      validateFunctionArgs args paramTypes localVarEnv globalVarEnv funEnv pos 
      Right returnType

checkExprType (EMul pos expr1 mulop expr2) localVarEnv globalVarEnv funEnv = do
  expr1Type <- checkExprType expr1 localVarEnv globalVarEnv funEnv
  expr2Type <- checkExprType expr2 localVarEnv globalVarEnv funEnv
  case (expr1Type, expr2Type) of
    ("int", "int") -> Right "int"
    _ -> Left (positionErrorDirectPos "Error: Multiplication requires two integers." pos)

checkExprType (EAdd pos expr1 addop expr2) localVarEnv globalVarEnv funEnv = do
  expr1Type <- checkExprType expr1 localVarEnv globalVarEnv funEnv
  expr2Type <- checkExprType expr2 localVarEnv globalVarEnv funEnv
  case (expr1Type, expr2Type) of
    ("int", "int") -> Right "int"
    ("string", "string") -> Right "string"
    _ -> Left (positionErrorDirectPos "Error: Addition requires two integers or strings." pos)

checkExprType (ERel pos expr1 relop expr2) localVarEnv globalVarEnv funEnv = do
  expr1Type <- checkExprType expr1 localVarEnv globalVarEnv funEnv
  expr2Type <- checkExprType expr2 localVarEnv globalVarEnv funEnv
  case (expr1Type, expr2Type) of
    ("int", "int") -> Right "bool" 
    ("bool", "bool") -> Right "bool"
    ("string", "string") -> 
      case relop of
        EQU _ -> Right "bool"
        NE _ -> Right "bool"
        _ -> Left (positionErrorDirectPos "Error: Invalid relational operator for strings (only == or != are allowed)." pos)
    _ -> Left (positionErrorDirectPos "Error: Relational operators require both operands to be of the same type (Int, Bool, or String)." pos)

checkExprType (EAnd pos expr1 expr2) localVarEnv globalVarEnv funEnv = do
  expr1Type <- checkExprType expr1 localVarEnv globalVarEnv funEnv
  expr2Type <- checkExprType expr2 localVarEnv globalVarEnv funEnv
  case (expr1Type, expr2Type) of
    ("bool", "bool") -> Right "bool"
    _ -> Left (positionErrorDirectPos "Error: 'AND' operator requires both operands to be of type 'Bool'." pos)

checkExprType (EOr pos expr1 expr2) localVarEnv globalVarEnv funEnv = do
  expr1Type <- checkExprType expr1 localVarEnv globalVarEnv funEnv
  expr2Type <- checkExprType expr2 localVarEnv globalVarEnv funEnv
  case (expr1Type, expr2Type) of
    ("bool", "bool") -> Right "bool"
    _ -> Left (positionErrorDirectPos "Error: 'OR' operator requires both operands to be of type 'Bool'." pos)

validateFunctionArgs :: [Expr] -> [String] -> VarEnv -> VarEnv -> Env -> BNFC'Position -> Err ()
validateFunctionArgs args paramTypes localVarEnv globalVarEnv funEnv pos = do
  if length args /= length paramTypes
    then Left (positionErrorDirectPos 
              ("Error: Incorrect number of arguments in function call. " ++
               "Expected " ++ show (length paramTypes) ++ ", got " ++ show (length args) ++ ".") 
              pos)
    else do
      argTypes <- mapM (\arg -> checkExprType arg localVarEnv globalVarEnv funEnv) args
      if argTypes == paramTypes
        then Right ()
        else Left (positionErrorDirectPos 
                  ("Error: Argument type mismatch in function call.\n" ++
                   "Expected types: " ++ show paramTypes ++ "\n" ++
                   "Got types: " ++ show argTypes) 
                  pos)

