-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelLatte where

import Prelude (($), Either(..), String, (++), Show, show, unwords, foldl, map, Bool(..), Maybe(..), null, (&&), not, (==), head, Eq)
import Control.Monad (foldM)
import qualified AbsLatte
import AbsLatte
import qualified Data.Map as Map

type Err = Either String
type Result = Err String

data FuncType = FuncType Type [Type] deriving (Show)

type Env = Map.Map String FuncType
type VarEnv = Map.Map String Type

builtinFunctions :: Env
builtinFunctions = Map.fromList
  [ ("printInt", FuncType (Void Nothing) [Int Nothing])
  , ("printString", FuncType (Void Nothing) [Str Nothing])
  , ("error", FuncType (Void Nothing) [])
  , ("readInt", FuncType (Int Nothing) [])
  , ("readString", FuncType (Str Nothing) [])
  ]

checkSemantics :: Program -> Result
checkSemantics program = do
  let collectResult = collectFunctionTypes program
  case collectResult of
    Left err -> Left err
    Right env -> do
      case Map.lookup "main" env of
        Nothing -> Left "Error: Function 'main' is not defined."
        Just (FuncType returnType argTypes) ->
          if not (isValidMainReturn returnType)
            then Left (positionError "Error: Function 'main' must return 'int'." returnType)
            else 
              if not (isValidMainArgs argTypes)
                then Left (positionError "Error: Function 'main' must take no arguments." (head argTypes))
                else transProgram program env

collectFunctionTypes :: Program -> Err Env
collectFunctionTypes (Program _ topdefs) = foldM addFunctionToEnv builtinFunctions topdefs

addFunctionToEnv :: Env -> TopDef -> Err Env
addFunctionToEnv env (FnDef pos returnType ident args _) = do
  let funcName = getIdentName ident
  if Map.member funcName env
    then 
      let message = "Error: Function '" ++ funcName ++ "' is already declared."
      in Left (positionErrorDirectPos message pos)
    else
      let argTypes = map getArgType args
          funcType = FuncType returnType argTypes
          updatedEnv = Map.insert funcName funcType env
      in Right updatedEnv

getIdentName :: Ident -> String
getIdentName (Ident name) = name

getArgType :: Arg -> Type
getArgType (Arg _ argType _) = argType

isValidMainReturn :: Type -> Bool
isValidMainReturn (Int _) = True
isValidMainReturn _ = False

isValidMainArgs :: [Type] -> Bool
isValidMainArgs argTypes = null argTypes

positionError :: String -> (HasPosition a) => a -> String
positionError message entity = do
  case hasPosition entity of
    Just pos -> "Error at position " ++ show pos ++ ": " ++ message
    Nothing  -> "Error: " ++ message

positionErrorDirectPos :: String -> BNFC'Position -> String
positionErrorDirectPos message pos = "Error at position " ++ show pos ++ ": " ++ message

transProgram :: Program -> Env -> Result
transProgram (Program _ topdefs) env = checkTopDefs topdefs env

checkTopDefs :: [TopDef] -> Env -> Result
checkTopDefs [] env = Right "OK"
checkTopDefs (topdef:rest) env = do
  case transTopDef topdef env of
    Left err -> Left err
    Right _  -> checkTopDefs rest env

transTopDef :: TopDef -> Env -> Result
transTopDef (FnDef _ _ ident args block) funEnv = do
  let varEnv = Map.empty
  case checkArgs args varEnv of
    Left err -> Left err
    Right _  -> checkBlock block varEnv funEnv

  
checkArgs :: [Arg] -> VarEnv -> Result
checkArgs [] varEnv = Right "All arguments processed"
checkArgs (Arg pos argType ident:rest) varEnv = do
  let varName = getIdentName ident
  if Map.member varName varEnv
    then 
      let message = "Error: Argument '" ++ varName ++ "' is already declared."
      in Left (positionErrorDirectPos message pos)
    else
      let updatedEnv = Map.insert varName argType varEnv
      in checkArgs rest updatedEnv

checkBlock :: Block -> VarEnv -> Env -> Result
checkBlock (Block _ stmts) varEnv funEnv = do
  case traverseStmts stmts varEnv funEnv of 
    Left err -> Left err
    Right _ -> Right "OK"

traverseStmts :: [Stmt] -> VarEnv -> Env -> Err VarEnv
traverseStmts [] varEnv _ = Right varEnv
traverseStmts (stmt:rest) varEnv funEnv = do
  let stmtResponse = checkStmt stmt varEnv funEnv
  case stmtResponse of
    Left err -> Left err
    Right newVarEnv -> traverseStmts rest newVarEnv funEnv

checkStmt :: Stmt -> VarEnv -> Env -> Err VarEnv
checkStmt (Decl pos varType items) varEnv _ = do
  let declResponse = processDecl pos varType items varEnv
  case declResponse of
    Left err -> Left err
    Right newVarEnv -> Right newVarEnv
   
checkStmt (Ass pos ident expr) varEnv _ = do
  let varName = getIdentName ident
  if Map.member varName varEnv
    then Right varEnv
    else Left (positionErrorDirectPos "Error: Variable not declared before assignment." pos)

checkStmt stmt varEnv _ = Right varEnv                                                     -- TODO exhaust

-- checkStmt (BStmt _ block) varEnv funEnv = do
--   checkBlock block varEnv funEnv

processDecl :: BNFC'Position -> Type -> [Item] -> VarEnv -> Err VarEnv
processDecl _ _ [] varEnv = Right varEnv
processDecl pos varType (item:rest) varEnv = do
  let processItemResponse = processItem pos varType item varEnv
  case processItemResponse of
    Left err -> Left err
    Right newVarEnv -> processDecl pos varType rest newVarEnv

processItem :: BNFC'Position -> Type -> Item -> VarEnv -> Err VarEnv
processItem pos varType (NoInit _ ident) varEnv = do
  let varName = getIdentName ident
  if Map.member varName varEnv
    then Left (positionErrorDirectPos ("Error: Variable '" ++ varName ++ "' already declared.") pos)
    else Right (Map.insert varName varType varEnv)
processItem pos varType item varEnv = Right varEnv                                        -- TODO exhaust

-- processItem pos varType (Init _ ident expr) varEnv = do                                -- TODO checkExprType
--   let varName = getIdentName ident
--   if Map.member varName varEnv
--     then Left (positionErrorDirectPos ("Error: Variable '" ++ varName ++ "' already declared.") pos)
--     else do
--       -- Here you might want to check the expression type (depending on the logic of your language)
--       let updatedEnv = Map.insert varName varType varEnv
--       Right updatedEnv

