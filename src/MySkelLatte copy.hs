-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelLatte where

import Prelude (($), Either(..), String, (++), Show, show, unwords, foldl, map, Bool(..), Maybe(..), null, (&&), not, (==), head)
import qualified AbsLatte
import AbsLatte
import qualified Data.Map as Map

type Err = Either String
type Result = Err String

data FuncType = FuncType Type [Type] deriving (Show)
type Env = Map.Map String FuncType
type VarEnv = Map.Map String Type

checkSemantics :: Program -> Result
checkSemantics program = do
  let env = collectFunctionTypes program
  case Map.lookup "main" env of
    Nothing -> Left "Error: Function 'main' is not defined."
    Just (FuncType returnType argTypes) ->
      if not (isValidMainReturn returnType)
        then Left (positionError "Error: Function 'main' must return 'int'." returnType)
        else 
          if not (isValidMainArgs argTypes)
            then Left (positionError "Error: Function 'main' must take no arguments." (head argTypes))
            else Right "OK"

collectFunctionTypes :: Program -> Env
collectFunctionTypes (Program _ topdefs) = foldl addFunctionToEnv Map.empty topdefs

addFunctionToEnv :: Env -> TopDef -> Env
addFunctionToEnv env (FnDef _ returnType ident args _) =
  let argTypes = map getArgType args
      funcType = FuncType returnType argTypes
   in Map.insert (getIdentName ident) funcType env

getIdentName :: Ident -> String
getIdentName (Ident name) = name

getArgType :: Arg -> Type
getArgType (Arg _ argType _) = argType

isValidMainReturn :: Type -> Bool
isValidMainReturn (Int _) = True
isValidMainReturn _ = False

isValidMainArgs :: [Type] -> Bool
isValidMainArgs argTypes = null argTypes

positionError :: String -> (HasPosition a) => a -> String
positionError message entity = do
  case hasPosition entity of
    Just pos -> "Error at position " ++ show pos ++ ": " ++ message
    Nothing  -> "Error: " ++ message

-- transProgram :: Program -> Env -> Result
-- transProgram (Program _ topdefs) env = checkTopDefs topdefs env

-- checkTopDefs :: [TopDef] -> Env -> Result
-- checkTopDefs [] env = Right "OK"
-- checkTopDefs (topdef:rest) env = do
--   case transTopDef topdef env of
--     Left err -> Left err
--     Right _  -> checkTopDefs rest env

-- transTopDef :: TopDef -> Env -> Result
-- transTopDef (FnDef _ type_ ident args block) env = do
--   let varEnv = checkArgs args Map.Empty
--   Right "OK"

-- checkArgs :: [Arg] -> VarEnv -> Result
-- checkArgs [] = Right "No arguments"
-- checkArgs (Arg _ _ ident:rest) = do
--   -- Tutaj możesz dodać bardziej szczegółowe sprawdzenie dla typów argumentów
--   checkArgs rest
--   return $ "Argument " ++ show ident ++ " processed."


-- checkSemantics :: Program -> Result
-- checkSemantics program = do
--   let funcNames = collectFunctionNames program
--   if "main" `elem` funcNames
--     then transProgram program
--     else Left "Error: Function 'main' is not defined."

-- -- Zbiera nazwy funkcji z programu
-- collectFunctionNames :: Program -> [String]
-- collectFunctionNames (Program _ topdefs) = traverseTopDefs topdefs

-- -- Przechodzi przez listę TopDef i zbiera nazwy funkcji
-- traverseTopDefs :: [TopDef] -> [String]
-- traverseTopDefs [] = [] -- Jeśli lista TopDef jest pusta, zwracamy pustą listę
-- traverseTopDefs (topdef:rest) = 
--   let funcName = getFunctionName topdef
--       restNames = traverseTopDefs rest
--   in funcName : restNames -- Dodajemy nazwę funkcji do listy

-- -- Pobiera nazwę funkcji z pojedynczego TopDef
-- getFunctionName :: TopDef -> String
-- getFunctionName (FnDef _ _ (Ident name) _ _) = name -- Zamienia Ident na String
