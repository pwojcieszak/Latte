# Latte compiler for LLVM
Latte compiler project for LLVM including parser, semantic analysis and generator along with optimizations.

## Compiling and running the program
We compile the project with a Makefile using the `make` command. An executable file latc_llvm will appear in the root of the project.

In order to run the program, you need to specify a file with expressions compatible with Latte grammar at the program input. Example of running:

`./latc_llvm ./lattests/good/core001.lat`

For better control, you can add a parameter to specify the level of optimization. This is done with the flag “-o%” where % is the digit 0-2. 
- o0 - basic version with constant folding, constant/variable propagation and reduction of unnecessary PHI 
- o1 - version '0' with LCSE added 
- o2 - version '1' with added GCSE and removal of dead code in the form of unused variables 

Specify the parameter anywhere after the program name, e.g:

`./latc_llvm lattests/good/core044.lat -o2`  
`./latc_llvm -o1 lattests/good/core044.lat`

Full `-o2` optimization is used by default.

## Tools and libraries used
 - BNFC - 2.9.4
 - GHC - 9.0.2
 - clang - 14.0.6

## Directory structure
```
.
├── lib
│   └── runtime.c
├── Makefile
├── README.md
└── src
    ├── AbsLatte.hs
    ├── Backend.hs
    ├── Frontend.hs
    ├── Latte.cf
    ├── LexLatte.hs
    ├── MainLatte.hs
    ├── Midend.hs
    ├── Optimizations.hs
    ├── ParLatte.hs
    ├── PrintLatte.hs
    └── StringParsers.hs
```


The /src primarily contains the main runtime files for the compiler:
  - MainLatte.hs - the program input point passing input files to the parser, calling the generator, creating output files,
  - Frontend.hs - frontend of the compiler
  - Backend.hs - the backend of the compiler
  - Midend.hs - optimizations made after the Frontend is finished but before the Backend. Currently it's just removing dead code after 'return'
  - Optimizations.hs - LCSE and GCSE optimizations, removing dead code
  - Latte.cf - Latte language grammar
  - StringParsers.hs - text parsers used in Backend and Optimizations.
  - The rest of the files are BNFC-generated Latte language parser files

In the /lib directory, the runtime.c file contains library functions written in C. List of functions: 
  - void printInt(int) -- prints Int
  - void printString(string) -- prints out String
  - void error() -- prints out an error message and stops the program
  - int readInt() -- reads Int from stdin
  - string readString() -- reads String from stdin
  - char* concat(char*,char*) -- concatenates two Strings

Po zbudowaniu, w korzeniu projektu pojawi się plik wykonywalny latc_llvm. Po uruchomieniu programu w folderze z plikiem wejściowym zostaną wygenerowane pliki .ll i .bc.

## Comments
### Statement in conditional instructions.
The body of a conditional can be a block or any other statement (nothing new). The reference to y in the branches of the statement is a reference to the “old” y, whose value is to change. Of course, you can create new local variables with the instructions int y = 2, int y =3, then y is local and does not change the “old” y, which is equal to 1 all the time.
```
int y = 1;
if (true)
    y = 2;
else
    y = 3;
printInt(y) // 2
```

### The error() function
The void error() function obviates the need for a succession of return commands.

### RelOps
By relational operators I mean “<”, “<=”, “>”, “>=”, “==”, “!=”.  
Inty supports all of them. String and Bool only support “==”, “!=”.

### Comparing String type
String type values are compared by reference.

### removeLastAssignment
This is a function used at the end of SExp processing, which is an expression intended to be assigned to nothing. The function modifies the last line generated by removing the assignment. The exception is when the last instruction is a PHI expression. Due to the text parser working afterwards detecting only PHI with an assignment, I decided not to remove the assignment in this case. This whole line will be removed anyway at the optimization stage, when it will be considered an assignment to an unused variable.

### Return and while(true) loop.
Assuming that we have a program with a “while(true)” loop, which terminates the program when the expected character is detected in the input, and so I require it to have a guaranteed (i.e. statically reachable) return.

## Optimizations
### Jumps in If and While branches.
If there is a return in the body (without checking the squashed blocks) of the condition branch then I do not add a jump to the final block and the edge between these blocks on the control flow graph.

### Constant folding
I fold static expressions like “b = (-7-1)*(7-1)” into “b = -48”. I perform the folding when generating the intermediate code.

### Constant / copy propagation
After generating the code, I analyze the simple assignments. In the case of an assignment where there is one simple argument (variable, constant) on the right side, I search for the use of the LHS variable in the following lines and replace its occurrences in the RHS.  

### LCSE
I perform LCSE as follows:  

In the input I have a map {BlockName -> [Code]}. For each block separately, I substitute the uses of variables with the same RHS (I delete the substituted declarations). The map of substituted variables is common to all blocks because of the PHI function, which can refer to a variable that we locally substituted in that other block. These blocks do not have to follow each other. In addition, one LCSE step can expose new places for improvement. For these two reasons, it is necessary to go through the LCSE more than once. In my algorithm, I optimize the LCSE as long as the resulting code differs from the input code.

I do not optimize function calls because of the possibility of using a function that reads from standard input in them.

### GCSE
In GCSE, it is important to follow the flow of blocks. A special case is the branching of a path under the influence of a condition, such as:

```
COND:
  br i1 %foo, label %TRUE, label %END
TRUE:
  %t_1 = add 2, 1
  %a = %t2
END:
  %t_2 = add 2, 1
  %b = %t2
```

In this case, the “END” block leads to both the “COND” block and the “TRUE” block. By passing the blocks one at a time, we could replace %t_2 with %t_1 but we have no assurance that we will actually pass the “TRUE” block when the program runs. The use of “%t_1” in the END block is not dominated. To recognize their presence in the conditional block, I gave them names with “TRUE” or “FALSE”. Their lines can be used to optimize all subsequent blocks except the block with the same number with the “END” suffix.

The same is true for Boolean expressions:
```
boolean a = 2>3 || 5>1;
```

The first OR condition (analogously for AND) will always execute, therefore it will be a pattern to be replaced. The second one executes only conditionally therefore it will not be written in patterns.  
Examples:
```
boolean a = 2>3 || 5>1;
boolean b = 5>1 || 2>3;
```

Part a:
```
  %t3.0 = icmp sgt i32 2, 3
  br i1 %t3.0, label %L1_exp_true, label %L2_or_mid_true
L2_or_mid_true:
  %t4.0 = icmp sgt i32 5, 1
  br i1 %t4.0, label %L1_exp_true, label %L1_exp_false
```

Part b:
```
%t6.0 = icmp sgt i32 5, 1
  br i1 %t6.0, label %L3_exp_true, label %L4_or_mid_true
L4_or_mid_true:
  br i1 %t3.0, label %L3_exp_true, label %L3_exp_false
```
In this case, I also took advantage of the clever naming of conditional blocks. In a sequence of AND or OR expressions, the second and subsequent expressions are in blocks having “MID” in their name. The expressions in the “MID” block cannot be used for optimization due to their conditional nature.

### Eliminating dead code
I remove dead code after “return” instructions immediately after semantic analysis.

I propagate redundant PHI due to equal values from preceding blocks or equal LHS (while_stmt -> while_cond) as a copy at different stages (at the end of the code without optimization, during LCSE, during GCSE) due to continuous changes in the code.

I eliminate unused variables during subsequent GCSE iterations. I did not do this during LCSE because a variable may not have a use in its block but be used in the next block.
